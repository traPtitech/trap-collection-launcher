/* tslint:disable */
/* eslint-disable */
/**
 * traPCollection API
 * traPCollectionのAPI
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common';
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  RequestArgs,
  BaseAPI,
  RequiredError,
} from './base';

/**
 * ゲームの更新・破損のチェック用リスト
 * @export
 * @interface CheckItem
 */
export interface CheckItem {
  /**
   *
   * @type {string}
   * @memberof CheckItem
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof CheckItem
   */
  md5: string;
  /**
   * ゲームの種類（url,jar,windows,mac）
   * @type {string}
   * @memberof CheckItem
   */
  type: string;
  /**
   * ゲーム本体の更新日時
   * @type {string}
   * @memberof CheckItem
   */
  bodyUpdatedAt: string;
  /**
   * 画像の更新日時
   * @type {string}
   * @memberof CheckItem
   */
  imgUpdatedAt: string;
  /**
   * 動画の更新日時
   * @type {string}
   * @memberof CheckItem
   */
  movieUpdatedAt: string;
}
/**
 * ゲーム
 * @export
 * @interface Game
 */
export interface Game {
  /**
   * ゲームのUUID
   * @type {string}
   * @memberof Game
   */
  id: string;
  /**
   * ゲーム名
   * @type {string}
   * @memberof Game
   */
  name: string;
  /**
   * ゲームの登録時刻
   * @type {string}
   * @memberof Game
   */
  createdAt: string;
  /**
   *
   * @type {GameVersion}
   * @memberof Game
   */
  version: GameVersion;
}
/**
 * ゲームのファイルの情報
 * @export
 * @interface GameFile
 */
export interface GameFile {
  /**
   * アセットのID
   * @type {number}
   * @memberof GameFile
   */
  id: number;
  /**
   * ゲームの種類（jar,windows,mac）
   * @type {string}
   * @memberof GameFile
   */
  type: string;
}
/**
 * ゲーム名とID
 * @export
 * @interface GameInfo
 */
export interface GameInfo {
  /**
   * 追加されたゲームのUUID
   * @type {string}
   * @memberof GameInfo
   */
  id: string;
  /**
   * 追加されたゲームの名前
   * @type {string}
   * @memberof GameInfo
   */
  name: string;
  /**
   * 追加されたゲームの説明
   * @type {string}
   * @memberof GameInfo
   */
  description: string;
  /**
   * ゲームの追加された時刻
   * @type {string}
   * @memberof GameInfo
   */
  createdAt: string;
}
/**
 * ゲーム名とID
 * @export
 * @interface GameMeta
 */
export interface GameMeta {
  /**
   * 追加されたゲームのUUID
   * @type {string}
   * @memberof GameMeta
   */
  id: string;
  /**
   * 追加されたゲームの名前
   * @type {string}
   * @memberof GameMeta
   */
  name: string;
}
/**
 * ゲームのURLの情報
 * @export
 * @interface GameURL
 */
export interface GameURL {
  /**
   * アセットのID
   * @type {number}
   * @memberof GameURL
   */
  id: number;
  /**
   * ゲームのURL（タイプがURL以外のときはなし）
   * @type {string}
   * @memberof GameURL
   */
  url: string;
}
/**
 * ゲームのバージョン
 * @export
 * @interface GameVersion
 */
export interface GameVersion {
  /**
   * ID
   * @type {number}
   * @memberof GameVersion
   */
  id: number;
  /**
   * 名前
   * @type {string}
   * @memberof GameVersion
   */
  name: string;
  /**
   * バージョンの説明
   * @type {string}
   * @memberof GameVersion
   */
  description: string;
  /**
   * 登録時刻
   * @type {string}
   * @memberof GameVersion
   */
  createdAt: string;
}
/**
 *
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
  /**
   *
   * @type {string}
   * @memberof InlineResponse200
   */
  code_challenge?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse200
   */
  code_challenge_method?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse200
   */
  client_id?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse200
   */
  response_type?: string;
}
/**
 * ランチャーのトークン
 * @export
 * @interface LauncherAuthToken
 */
export interface LauncherAuthToken {
  /**
   *
   * @type {string}
   * @memberof LauncherAuthToken
   */
  accessToken: string;
  /**
   * アクセストークンの持続時間(秒)
   * @type {number}
   * @memberof LauncherAuthToken
   */
  expiresIn: number;
  /**
   *
   * @type {string}
   * @memberof LauncherAuthToken
   */
  refreshToken: string;
}
/**
 *
 * @export
 * @interface Maintainer
 */
export interface Maintainer {
  /**
   * traQID（UUID）
   * @type {string}
   * @memberof Maintainer
   */
  id: string;
  /**
   * traQID（UUIDでない方）
   * @type {string}
   * @memberof Maintainer
   */
  name: string;
  /**
   * 権限（0:ゲームの更新の権限のみ,1:ゲームの更新と更新権限を持つ人の追加の権限を持つ）
   * @type {number}
   * @memberof Maintainer
   */
  role: number;
}
/**
 * 管理者の一覧
 * @export
 * @interface Maintainers
 */
export interface Maintainers {
  /**
   *
   * @type {Array<string>}
   * @memberof Maintainers
   */
  maintainers: Array<string>;
}
/**
 * 新しいゲームの名前
 * @export
 * @interface NewGame
 */
export interface NewGame {
  /**
   * 修正後のゲームの名前
   * @type {string}
   * @memberof NewGame
   */
  name: string;
  /**
   * 修正後のゲームの説明文
   * @type {string}
   * @memberof NewGame
   */
  description: string;
}
/**
 * 新しいゲームのURL
 * @export
 * @interface NewGameURL
 */
export interface NewGameURL {
  /**
   * URL
   * @type {string}
   * @memberof NewGameURL
   */
  url: string;
}
/**
 * 新しいゲームのバージョン
 * @export
 * @interface NewGameVersion
 */
export interface NewGameVersion {
  /**
   * 名前
   * @type {string}
   * @memberof NewGameVersion
   */
  name: string;
  /**
   * バージョンの説明
   * @type {string}
   * @memberof NewGameVersion
   */
  description: string;
}
/**
 * 新しいランチャーのバージョンの名前
 * @export
 * @interface NewVersion
 */
export interface NewVersion {
  /**
   * バージョンの名前
   * @type {string}
   * @memberof NewVersion
   */
  name: string;
  /**
   * アンケートのURL
   * @type {string}
   * @memberof NewVersion
   */
  anke_to?: string;
}
/**
 * プロダクトキー
 * @export
 * @interface ProductKey
 */
export interface ProductKey {
  /**
   * プロダクトキー
   * @type {string}
   * @memberof ProductKey
   */
  key: string;
}
/**
 * プロダクトキーの詳細
 * @export
 * @interface ProductKeyDetail
 */
export interface ProductKeyDetail {
  /**
   * プロダクトキーのID
   * @type {string}
   * @memberof ProductKeyDetail
   */
  id?: string;
  /**
   * プロダクトキー
   * @type {string}
   * @memberof ProductKeyDetail
   */
  key: string;
}
/**
 * プロダクトキー生成のリクエスト
 * @export
 * @interface ProductKeyGen
 */
export interface ProductKeyGen {
  /**
   *
   * @type {number}
   * @memberof ProductKeyGen
   */
  num: number;
  /**
   * バージョンID
   * @type {number}
   * @memberof ProductKeyGen
   */
  version: number;
}
/**
 * 席
 * @export
 * @interface Seat
 */
export interface Seat {
  /**
   *
   * @type {number}
   * @memberof Seat
   */
  seatVersionId: number;
  /**
   *
   * @type {number}
   * @memberof Seat
   */
  seatId: number;
}
/**
 * 席の詳細
 * @export
 * @interface SeatDetail
 */
export interface SeatDetail {
  /**
   *
   * @type {number}
   * @memberof SeatDetail
   */
  id: number;
  /**
   * 席の状態(0で離席、1で着席)
   * @type {number}
   * @memberof SeatDetail
   */
  status: number;
  /**
   * 着席時刻
   * @type {string}
   * @memberof SeatDetail
   */
  SeatingTime?: string;
}
/**
 * 席のバージョン
 * @export
 * @interface SeatVersion
 */
export interface SeatVersion {
  /**
   *
   * @type {number}
   * @memberof SeatVersion
   */
  id: number;
  /**
   * 作成時刻
   * @type {string}
   * @memberof SeatVersion
   */
  createdAt: string;
}
/**
 * ユーザー
 * @export
 * @interface User
 */
export interface User {
  /**
   * traQのID（UUID）
   * @type {string}
   * @memberof User
   */
  id?: string;
  /**
   * traQID（UUIDでない方）
   * @type {string}
   * @memberof User
   */
  name: string;
}
/**
 * ランチャーのバージョン
 * @export
 * @interface Version
 */
export interface Version {
  /**
   * ID
   * @type {number}
   * @memberof Version
   */
  id: number;
  /**
   * 名前
   * @type {string}
   * @memberof Version
   */
  name: string;
  /**
   * アンケートのURL
   * @type {string}
   * @memberof Version
   */
  anke_to?: string;
  /**
   * 登録時刻
   * @type {string}
   * @memberof Version
   */
  createdAt: string;
}
/**
 * ランチャーのバージョン詳細
 * @export
 * @interface VersionDetails
 */
export interface VersionDetails {
  /**
   * ID
   * @type {number}
   * @memberof VersionDetails
   */
  id: number;
  /**
   * 名前
   * @type {string}
   * @memberof VersionDetails
   */
  name: string;
  /**
   * アンケートのURL
   * @type {string}
   * @memberof VersionDetails
   */
  anke_to?: string;
  /**
   *
   * @type {Array<GameMeta>}
   * @memberof VersionDetails
   */
  games: Array<GameMeta>;
  /**
   * 登録時刻
   * @type {string}
   * @memberof VersionDetails
   */
  createdAt: string;
}
/**
 * ランチャーのバージョンの簡易的な情報
 * @export
 * @interface VersionMeta
 */
export interface VersionMeta {
  /**
   * ID
   * @type {number}
   * @memberof VersionMeta
   */
  id: number;
  /**
   * 名前
   * @type {string}
   * @memberof VersionMeta
   */
  name: string;
  /**
   * アンケートのURL
   * @type {string}
   * @memberof VersionMeta
   */
  anke_to?: string;
  /**
   * 登録時刻
   * @type {string}
   * @memberof VersionMeta
   */
  createdAt: string;
}

/**
 * GameApi - axios parameter creator
 * @export
 */
export const GameApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * ゲームの削除
     * @summary ゲームの削除
     * @param {string} gameID ゲームのUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteGames: async (
      gameID: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'gameID' is not null or undefined
      assertParamExists('deleteGames', 'gameID', gameID);
      const localVarPath = `/games/{gameID}`.replace(
        `{${'gameID'}}`,
        encodeURIComponent(String(gameID))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication GameMaintainerAuth required

      // authentication TrapMemberAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'TrapMemberAuth',
        ['read'],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * ゲーム情報の取得
     * @summary ゲーム情報の取得
     * @param {string} gameID ゲームのUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGame: async (
      gameID: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'gameID' is not null or undefined
      assertParamExists('getGame', 'gameID', gameID);
      const localVarPath = `/games/{gameID}/info`.replace(
        `{${'gameID'}}`,
        encodeURIComponent(String(gameID))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication LauncherAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication TrapMemberAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'TrapMemberAuth',
        ['read'],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * ゲームの最新バージョンのファイルの取得
     * @summary ゲームの最新バージョンのファイルの取得
     * @param {string} gameID ゲームのUUID
     * @param {string} operatingSystem osのパラメーター(mac,windows)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGameFile: async (
      gameID: string,
      operatingSystem: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'gameID' is not null or undefined
      assertParamExists('getGameFile', 'gameID', gameID);
      // verify required parameter 'operatingSystem' is not null or undefined
      assertParamExists('getGameFile', 'operatingSystem', operatingSystem);
      const localVarPath = `/games/asset/{gameID}/file`.replace(
        `{${'gameID'}}`,
        encodeURIComponent(String(gameID))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication LauncherAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication TrapMemberAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'TrapMemberAuth',
        ['read'],
        configuration
      );

      if (operatingSystem !== undefined) {
        localVarQueryParameter['operatingSystem'] = operatingSystem;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * ゲームの最新バージョンのURLの取得
     * @summary ゲームの最新バージョンのURLの取得
     * @param {string} gameID ゲームのUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGameURL: async (
      gameID: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'gameID' is not null or undefined
      assertParamExists('getGameURL', 'gameID', gameID);
      const localVarPath = `/games/asset/{gameID}/url`.replace(
        `{${'gameID'}}`,
        encodeURIComponent(String(gameID))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication LauncherAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication TrapMemberAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'TrapMemberAuth',
        ['read'],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * ゲームのバージョン一覧の取得
     * @summary ゲームのバージョン一覧の取得
     * @param {string} gameID ゲームのUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGameVersion: async (
      gameID: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'gameID' is not null or undefined
      assertParamExists('getGameVersion', 'gameID', gameID);
      const localVarPath = `/games/{gameID}/version`.replace(
        `{${'gameID'}}`,
        encodeURIComponent(String(gameID))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication TrapMemberAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'TrapMemberAuth',
        ['read'],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * ゲーム一覧の取得
     * @summary ゲーム一覧の取得
     * @param {boolean} [all] trueですべてのゲーム、そうでないとき自分がadminまたはmaintainerのゲーム
     * @param {string} [sessions]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGames: async (
      all?: boolean,
      sessions?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/games`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication TrapMemberAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'TrapMemberAuth',
        ['read'],
        configuration
      );

      if (all !== undefined) {
        localVarQueryParameter['all'] = all;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * ゲームの画像の取得
     * @summary ゲームの画像の取得
     * @param {string} gameID ゲームのUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getImage: async (
      gameID: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'gameID' is not null or undefined
      assertParamExists('getImage', 'gameID', gameID);
      const localVarPath = `/games/{gameID}/image`.replace(
        `{${'gameID'}}`,
        encodeURIComponent(String(gameID))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication LauncherAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication TrapMemberAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'TrapMemberAuth',
        ['read'],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * ゲームの管理者の取得
     * @summary ゲームの管理者の取得
     * @param {string} gameID ゲームのUUID
     * @param {string} [sessions]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMaintainer: async (
      gameID: string,
      sessions?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'gameID' is not null or undefined
      assertParamExists('getMaintainer', 'gameID', gameID);
      const localVarPath = `/games/{gameID}/maintainers`.replace(
        `{${'gameID'}}`,
        encodeURIComponent(String(gameID))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication TrapMemberAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'TrapMemberAuth',
        ['read'],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * ゲームの動画の取得
     * @summary ゲームの動画の取得
     * @param {string} gameID ゲームのUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVideo: async (
      gameID: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'gameID' is not null or undefined
      assertParamExists('getVideo', 'gameID', gameID);
      const localVarPath = `/games/{gameID}/video`.replace(
        `{${'gameID'}}`,
        encodeURIComponent(String(gameID))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication LauncherAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication TrapMemberAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'TrapMemberAuth',
        ['read'],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * ゲームの最新バージョンへのファイルの追加
     * @summary ゲームの最新バージョンへのファイルの追加
     * @param {string} gameID ゲームのUUID
     * @param {string} type ゲームの種類（jar,windows,mac）
     * @param {any} file ゲームのファイル
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postFile: async (
      gameID: string,
      type: string,
      file: any,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'gameID' is not null or undefined
      assertParamExists('postFile', 'gameID', gameID);
      // verify required parameter 'type' is not null or undefined
      assertParamExists('postFile', 'type', type);
      // verify required parameter 'file' is not null or undefined
      assertParamExists('postFile', 'file', file);
      const localVarPath = `/games/asset/{gameID}/file`.replace(
        `{${'gameID'}}`,
        encodeURIComponent(String(gameID))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new ((configuration &&
        configuration.formDataCtor) ||
        FormData)();

      // authentication GameMaintainerAuth required

      // authentication TrapMemberAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'TrapMemberAuth',
        ['read'],
        configuration
      );

      if (type !== undefined) {
        localVarFormParams.append('type', type as any);
      }

      if (file !== undefined) {
        localVarFormParams.append('file', file as any);
      }

      localVarHeaderParameter['Content-Type'] = 'multipart/form-data';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = localVarFormParams;

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * ゲームの追加
     * @summary ゲームの追加
     * @param {string} [sessions]
     * @param {NewGame} [newGame]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postGame: async (
      sessions?: string,
      newGame?: NewGame,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/games`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication TrapMemberAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'TrapMemberAuth',
        ['read'],
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        newGame,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * ゲームのバージョンの作成
     * @summary ゲームのバージョンの作成
     * @param {string} gameID ゲームのUUID
     * @param {NewGameVersion} [newGameVersion]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postGameVersion: async (
      gameID: string,
      newGameVersion?: NewGameVersion,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'gameID' is not null or undefined
      assertParamExists('postGameVersion', 'gameID', gameID);
      const localVarPath = `/games/{gameID}/version`.replace(
        `{${'gameID'}}`,
        encodeURIComponent(String(gameID))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication GameMaintainerAuth required

      // authentication TrapMemberAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'TrapMemberAuth',
        ['read'],
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        newGameVersion,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * ゲームの画像の変更
     * @summary ゲームの画像の変更
     * @param {string} gameID ゲームのUUID
     * @param {any} [file]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postImage: async (
      gameID: string,
      file?: any,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'gameID' is not null or undefined
      assertParamExists('postImage', 'gameID', gameID);
      const localVarPath = `/games/{gameID}/image`.replace(
        `{${'gameID'}}`,
        encodeURIComponent(String(gameID))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new ((configuration &&
        configuration.formDataCtor) ||
        FormData)();

      // authentication GameMaintainerAuth required

      // authentication TrapMemberAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'TrapMemberAuth',
        ['read'],
        configuration
      );

      if (file !== undefined) {
        localVarFormParams.append('file', file as any);
      }

      localVarHeaderParameter['Content-Type'] = 'multipart/form-data';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = localVarFormParams;

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * ゲームのバージョン更新権限保持者の追加
     * @summary ゲームのバージョン更新権限保持者の追加
     * @param {string} gameID ゲームのUUID
     * @param {string} [sessions]
     * @param {Maintainers} [maintainers]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postMaintainer: async (
      gameID: string,
      sessions?: string,
      maintainers?: Maintainers,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'gameID' is not null or undefined
      assertParamExists('postMaintainer', 'gameID', gameID);
      const localVarPath = `/games/{gameID}/maintainers`.replace(
        `{${'gameID'}}`,
        encodeURIComponent(String(gameID))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication GameMaintainerAuth required

      // authentication TrapMemberAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'TrapMemberAuth',
        ['read'],
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        maintainers,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * ゲームの最新バージョンへのURLの追加
     * @summary ゲームの最新バージョンへのURLの追加
     * @param {string} gameID ゲームのUUID
     * @param {NewGameURL} [newGameURL]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postURL: async (
      gameID: string,
      newGameURL?: NewGameURL,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'gameID' is not null or undefined
      assertParamExists('postURL', 'gameID', gameID);
      const localVarPath = `/games/asset/{gameID}/url`.replace(
        `{${'gameID'}}`,
        encodeURIComponent(String(gameID))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication GameMaintainerAuth required

      // authentication TrapMemberAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'TrapMemberAuth',
        ['read'],
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        newGameURL,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * ゲームの動画の変更
     * @summary ゲームの動画の変更
     * @param {string} gameID ゲームのUUID
     * @param {any} [file]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postVideo: async (
      gameID: string,
      file?: any,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'gameID' is not null or undefined
      assertParamExists('postVideo', 'gameID', gameID);
      const localVarPath = `/games/{gameID}/video`.replace(
        `{${'gameID'}}`,
        encodeURIComponent(String(gameID))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new ((configuration &&
        configuration.formDataCtor) ||
        FormData)();

      // authentication GameMaintainerAuth required

      // authentication TrapMemberAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'TrapMemberAuth',
        ['read'],
        configuration
      );

      if (file !== undefined) {
        localVarFormParams.append('file', file as any);
      }

      localVarHeaderParameter['Content-Type'] = 'multipart/form-data';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = localVarFormParams;

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * ゲームの情報の修正
     * @summary ゲームの情報の修正
     * @param {string} gameID ゲームのUUID
     * @param {NewGame} [newGame]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putGame: async (
      gameID: string,
      newGame?: NewGame,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'gameID' is not null or undefined
      assertParamExists('putGame', 'gameID', gameID);
      const localVarPath = `/games/{gameID}/info`.replace(
        `{${'gameID'}}`,
        encodeURIComponent(String(gameID))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication GameMaintainerAuth required

      // authentication TrapMemberAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'TrapMemberAuth',
        ['read'],
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        newGame,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * GameApi - functional programming interface
 * @export
 */
export const GameApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = GameApiAxiosParamCreator(configuration);
  return {
    /**
     * ゲームの削除
     * @summary ゲームの削除
     * @param {string} gameID ゲームのUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteGames(
      gameID: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGames(
        gameID,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * ゲーム情報の取得
     * @summary ゲーム情報の取得
     * @param {string} gameID ゲームのUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getGame(
      gameID: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Game>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getGame(
        gameID,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * ゲームの最新バージョンのファイルの取得
     * @summary ゲームの最新バージョンのファイルの取得
     * @param {string} gameID ゲームのUUID
     * @param {string} operatingSystem osのパラメーター(mac,windows)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getGameFile(
      gameID: string,
      operatingSystem: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getGameFile(
        gameID,
        operatingSystem,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * ゲームの最新バージョンのURLの取得
     * @summary ゲームの最新バージョンのURLの取得
     * @param {string} gameID ゲームのUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getGameURL(
      gameID: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getGameURL(
        gameID,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * ゲームのバージョン一覧の取得
     * @summary ゲームのバージョン一覧の取得
     * @param {string} gameID ゲームのUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getGameVersion(
      gameID: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<GameVersion>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getGameVersion(
        gameID,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * ゲーム一覧の取得
     * @summary ゲーム一覧の取得
     * @param {boolean} [all] trueですべてのゲーム、そうでないとき自分がadminまたはmaintainerのゲーム
     * @param {string} [sessions]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getGames(
      all?: boolean,
      sessions?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Game>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getGames(
        all,
        sessions,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * ゲームの画像の取得
     * @summary ゲームの画像の取得
     * @param {string} gameID ゲームのUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getImage(
      gameID: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getImage(
        gameID,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * ゲームの管理者の取得
     * @summary ゲームの管理者の取得
     * @param {string} gameID ゲームのUUID
     * @param {string} [sessions]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getMaintainer(
      gameID: string,
      sessions?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<Maintainer>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getMaintainer(
        gameID,
        sessions,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * ゲームの動画の取得
     * @summary ゲームの動画の取得
     * @param {string} gameID ゲームのUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getVideo(
      gameID: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getVideo(
        gameID,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * ゲームの最新バージョンへのファイルの追加
     * @summary ゲームの最新バージョンへのファイルの追加
     * @param {string} gameID ゲームのUUID
     * @param {string} type ゲームの種類（jar,windows,mac）
     * @param {any} file ゲームのファイル
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postFile(
      gameID: string,
      type: string,
      file: any,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<GameFile>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.postFile(
        gameID,
        type,
        file,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * ゲームの追加
     * @summary ゲームの追加
     * @param {string} [sessions]
     * @param {NewGame} [newGame]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postGame(
      sessions?: string,
      newGame?: NewGame,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<GameInfo>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.postGame(
        sessions,
        newGame,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * ゲームのバージョンの作成
     * @summary ゲームのバージョンの作成
     * @param {string} gameID ゲームのUUID
     * @param {NewGameVersion} [newGameVersion]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postGameVersion(
      gameID: string,
      newGameVersion?: NewGameVersion,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<GameVersion>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.postGameVersion(
        gameID,
        newGameVersion,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * ゲームの画像の変更
     * @summary ゲームの画像の変更
     * @param {string} gameID ゲームのUUID
     * @param {any} [file]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postImage(
      gameID: string,
      file?: any,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.postImage(
        gameID,
        file,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * ゲームのバージョン更新権限保持者の追加
     * @summary ゲームのバージョン更新権限保持者の追加
     * @param {string} gameID ゲームのUUID
     * @param {string} [sessions]
     * @param {Maintainers} [maintainers]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postMaintainer(
      gameID: string,
      sessions?: string,
      maintainers?: Maintainers,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.postMaintainer(
        gameID,
        sessions,
        maintainers,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * ゲームの最新バージョンへのURLの追加
     * @summary ゲームの最新バージョンへのURLの追加
     * @param {string} gameID ゲームのUUID
     * @param {NewGameURL} [newGameURL]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postURL(
      gameID: string,
      newGameURL?: NewGameURL,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<GameURL>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.postURL(
        gameID,
        newGameURL,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * ゲームの動画の変更
     * @summary ゲームの動画の変更
     * @param {string} gameID ゲームのUUID
     * @param {any} [file]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postVideo(
      gameID: string,
      file?: any,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.postVideo(
        gameID,
        file,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * ゲームの情報の修正
     * @summary ゲームの情報の修正
     * @param {string} gameID ゲームのUUID
     * @param {NewGame} [newGame]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async putGame(
      gameID: string,
      newGame?: NewGame,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<GameInfo>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.putGame(
        gameID,
        newGame,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * GameApi - factory interface
 * @export
 */
export const GameApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = GameApiFp(configuration);
  return {
    /**
     * ゲームの削除
     * @summary ゲームの削除
     * @param {string} gameID ゲームのUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteGames(gameID: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .deleteGames(gameID, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * ゲーム情報の取得
     * @summary ゲーム情報の取得
     * @param {string} gameID ゲームのUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGame(gameID: string, options?: any): AxiosPromise<Game> {
      return localVarFp
        .getGame(gameID, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * ゲームの最新バージョンのファイルの取得
     * @summary ゲームの最新バージョンのファイルの取得
     * @param {string} gameID ゲームのUUID
     * @param {string} operatingSystem osのパラメーター(mac,windows)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGameFile(
      gameID: string,
      operatingSystem: string,
      options?: any
    ): AxiosPromise<any> {
      return localVarFp
        .getGameFile(gameID, operatingSystem, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * ゲームの最新バージョンのURLの取得
     * @summary ゲームの最新バージョンのURLの取得
     * @param {string} gameID ゲームのUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGameURL(gameID: string, options?: any): AxiosPromise<string> {
      return localVarFp
        .getGameURL(gameID, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * ゲームのバージョン一覧の取得
     * @summary ゲームのバージョン一覧の取得
     * @param {string} gameID ゲームのUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGameVersion(
      gameID: string,
      options?: any
    ): AxiosPromise<Array<GameVersion>> {
      return localVarFp
        .getGameVersion(gameID, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * ゲーム一覧の取得
     * @summary ゲーム一覧の取得
     * @param {boolean} [all] trueですべてのゲーム、そうでないとき自分がadminまたはmaintainerのゲーム
     * @param {string} [sessions]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGames(
      all?: boolean,
      sessions?: string,
      options?: any
    ): AxiosPromise<Array<Game>> {
      return localVarFp
        .getGames(all, sessions, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * ゲームの画像の取得
     * @summary ゲームの画像の取得
     * @param {string} gameID ゲームのUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getImage(gameID: string, options?: any): AxiosPromise<any> {
      return localVarFp
        .getImage(gameID, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * ゲームの管理者の取得
     * @summary ゲームの管理者の取得
     * @param {string} gameID ゲームのUUID
     * @param {string} [sessions]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMaintainer(
      gameID: string,
      sessions?: string,
      options?: any
    ): AxiosPromise<Array<Maintainer>> {
      return localVarFp
        .getMaintainer(gameID, sessions, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * ゲームの動画の取得
     * @summary ゲームの動画の取得
     * @param {string} gameID ゲームのUUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVideo(gameID: string, options?: any): AxiosPromise<any> {
      return localVarFp
        .getVideo(gameID, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * ゲームの最新バージョンへのファイルの追加
     * @summary ゲームの最新バージョンへのファイルの追加
     * @param {string} gameID ゲームのUUID
     * @param {string} type ゲームの種類（jar,windows,mac）
     * @param {any} file ゲームのファイル
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postFile(
      gameID: string,
      type: string,
      file: any,
      options?: any
    ): AxiosPromise<GameFile> {
      return localVarFp
        .postFile(gameID, type, file, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * ゲームの追加
     * @summary ゲームの追加
     * @param {string} [sessions]
     * @param {NewGame} [newGame]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postGame(
      sessions?: string,
      newGame?: NewGame,
      options?: any
    ): AxiosPromise<GameInfo> {
      return localVarFp
        .postGame(sessions, newGame, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * ゲームのバージョンの作成
     * @summary ゲームのバージョンの作成
     * @param {string} gameID ゲームのUUID
     * @param {NewGameVersion} [newGameVersion]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postGameVersion(
      gameID: string,
      newGameVersion?: NewGameVersion,
      options?: any
    ): AxiosPromise<GameVersion> {
      return localVarFp
        .postGameVersion(gameID, newGameVersion, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * ゲームの画像の変更
     * @summary ゲームの画像の変更
     * @param {string} gameID ゲームのUUID
     * @param {any} [file]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postImage(gameID: string, file?: any, options?: any): AxiosPromise<void> {
      return localVarFp
        .postImage(gameID, file, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * ゲームのバージョン更新権限保持者の追加
     * @summary ゲームのバージョン更新権限保持者の追加
     * @param {string} gameID ゲームのUUID
     * @param {string} [sessions]
     * @param {Maintainers} [maintainers]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postMaintainer(
      gameID: string,
      sessions?: string,
      maintainers?: Maintainers,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .postMaintainer(gameID, sessions, maintainers, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * ゲームの最新バージョンへのURLの追加
     * @summary ゲームの最新バージョンへのURLの追加
     * @param {string} gameID ゲームのUUID
     * @param {NewGameURL} [newGameURL]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postURL(
      gameID: string,
      newGameURL?: NewGameURL,
      options?: any
    ): AxiosPromise<GameURL> {
      return localVarFp
        .postURL(gameID, newGameURL, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * ゲームの動画の変更
     * @summary ゲームの動画の変更
     * @param {string} gameID ゲームのUUID
     * @param {any} [file]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postVideo(gameID: string, file?: any, options?: any): AxiosPromise<void> {
      return localVarFp
        .postVideo(gameID, file, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * ゲームの情報の修正
     * @summary ゲームの情報の修正
     * @param {string} gameID ゲームのUUID
     * @param {NewGame} [newGame]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putGame(
      gameID: string,
      newGame?: NewGame,
      options?: any
    ): AxiosPromise<GameInfo> {
      return localVarFp
        .putGame(gameID, newGame, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * GameApi - object-oriented interface
 * @export
 * @class GameApi
 * @extends {BaseAPI}
 */
export class GameApi extends BaseAPI {
  /**
   * ゲームの削除
   * @summary ゲームの削除
   * @param {string} gameID ゲームのUUID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GameApi
   */
  public deleteGames(gameID: string, options?: any) {
    return GameApiFp(this.configuration)
      .deleteGames(gameID, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * ゲーム情報の取得
   * @summary ゲーム情報の取得
   * @param {string} gameID ゲームのUUID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GameApi
   */
  public getGame(gameID: string, options?: any) {
    return GameApiFp(this.configuration)
      .getGame(gameID, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * ゲームの最新バージョンのファイルの取得
   * @summary ゲームの最新バージョンのファイルの取得
   * @param {string} gameID ゲームのUUID
   * @param {string} operatingSystem osのパラメーター(mac,windows)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GameApi
   */
  public getGameFile(gameID: string, operatingSystem: string, options?: any) {
    return GameApiFp(this.configuration)
      .getGameFile(gameID, operatingSystem, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * ゲームの最新バージョンのURLの取得
   * @summary ゲームの最新バージョンのURLの取得
   * @param {string} gameID ゲームのUUID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GameApi
   */
  public getGameURL(gameID: string, options?: any) {
    return GameApiFp(this.configuration)
      .getGameURL(gameID, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * ゲームのバージョン一覧の取得
   * @summary ゲームのバージョン一覧の取得
   * @param {string} gameID ゲームのUUID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GameApi
   */
  public getGameVersion(gameID: string, options?: any) {
    return GameApiFp(this.configuration)
      .getGameVersion(gameID, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * ゲーム一覧の取得
   * @summary ゲーム一覧の取得
   * @param {boolean} [all] trueですべてのゲーム、そうでないとき自分がadminまたはmaintainerのゲーム
   * @param {string} [sessions]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GameApi
   */
  public getGames(all?: boolean, sessions?: string, options?: any) {
    return GameApiFp(this.configuration)
      .getGames(all, sessions, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * ゲームの画像の取得
   * @summary ゲームの画像の取得
   * @param {string} gameID ゲームのUUID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GameApi
   */
  public getImage(gameID: string, options?: any) {
    return GameApiFp(this.configuration)
      .getImage(gameID, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * ゲームの管理者の取得
   * @summary ゲームの管理者の取得
   * @param {string} gameID ゲームのUUID
   * @param {string} [sessions]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GameApi
   */
  public getMaintainer(gameID: string, sessions?: string, options?: any) {
    return GameApiFp(this.configuration)
      .getMaintainer(gameID, sessions, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * ゲームの動画の取得
   * @summary ゲームの動画の取得
   * @param {string} gameID ゲームのUUID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GameApi
   */
  public getVideo(gameID: string, options?: any) {
    return GameApiFp(this.configuration)
      .getVideo(gameID, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * ゲームの最新バージョンへのファイルの追加
   * @summary ゲームの最新バージョンへのファイルの追加
   * @param {string} gameID ゲームのUUID
   * @param {string} type ゲームの種類（jar,windows,mac）
   * @param {any} file ゲームのファイル
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GameApi
   */
  public postFile(gameID: string, type: string, file: any, options?: any) {
    return GameApiFp(this.configuration)
      .postFile(gameID, type, file, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * ゲームの追加
   * @summary ゲームの追加
   * @param {string} [sessions]
   * @param {NewGame} [newGame]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GameApi
   */
  public postGame(sessions?: string, newGame?: NewGame, options?: any) {
    return GameApiFp(this.configuration)
      .postGame(sessions, newGame, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * ゲームのバージョンの作成
   * @summary ゲームのバージョンの作成
   * @param {string} gameID ゲームのUUID
   * @param {NewGameVersion} [newGameVersion]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GameApi
   */
  public postGameVersion(
    gameID: string,
    newGameVersion?: NewGameVersion,
    options?: any
  ) {
    return GameApiFp(this.configuration)
      .postGameVersion(gameID, newGameVersion, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * ゲームの画像の変更
   * @summary ゲームの画像の変更
   * @param {string} gameID ゲームのUUID
   * @param {any} [file]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GameApi
   */
  public postImage(gameID: string, file?: any, options?: any) {
    return GameApiFp(this.configuration)
      .postImage(gameID, file, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * ゲームのバージョン更新権限保持者の追加
   * @summary ゲームのバージョン更新権限保持者の追加
   * @param {string} gameID ゲームのUUID
   * @param {string} [sessions]
   * @param {Maintainers} [maintainers]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GameApi
   */
  public postMaintainer(
    gameID: string,
    sessions?: string,
    maintainers?: Maintainers,
    options?: any
  ) {
    return GameApiFp(this.configuration)
      .postMaintainer(gameID, sessions, maintainers, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * ゲームの最新バージョンへのURLの追加
   * @summary ゲームの最新バージョンへのURLの追加
   * @param {string} gameID ゲームのUUID
   * @param {NewGameURL} [newGameURL]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GameApi
   */
  public postURL(gameID: string, newGameURL?: NewGameURL, options?: any) {
    return GameApiFp(this.configuration)
      .postURL(gameID, newGameURL, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * ゲームの動画の変更
   * @summary ゲームの動画の変更
   * @param {string} gameID ゲームのUUID
   * @param {any} [file]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GameApi
   */
  public postVideo(gameID: string, file?: any, options?: any) {
    return GameApiFp(this.configuration)
      .postVideo(gameID, file, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * ゲームの情報の修正
   * @summary ゲームの情報の修正
   * @param {string} gameID ゲームのUUID
   * @param {NewGame} [newGame]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GameApi
   */
  public putGame(gameID: string, newGame?: NewGame, options?: any) {
    return GameApiFp(this.configuration)
      .putGame(gameID, newGame, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * LauncherAuthApi - axios parameter creator
 * @export
 */
export const LauncherAuthApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * プロダクトキー失効
     * @summary プロダクトキー失効
     * @param {string} productKeyID productKeyのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteProductKey: async (
      productKeyID: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'productKeyID' is not null or undefined
      assertParamExists('deleteProductKey', 'productKeyID', productKeyID);
      const localVarPath = `/launcher/key/{productKeyID}`.replace(
        `{${'productKeyID'}}`,
        encodeURIComponent(String(productKeyID))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication AdminAuth required

      // authentication TrapMemberAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'TrapMemberAuth',
        ['read'],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * バージョンのプロダクトキー一覧
     * @summary バージョンのプロダクトキー一覧
     * @param {number} launcherVersionID ランチャーのバージョンのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProductKeys: async (
      launcherVersionID: number,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'launcherVersionID' is not null or undefined
      assertParamExists(
        'getProductKeys',
        'launcherVersionID',
        launcherVersionID
      );
      const localVarPath = `/versions/{launcherVersionID}/keys`.replace(
        `{${'launcherVersionID'}}`,
        encodeURIComponent(String(launcherVersionID))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication AdminAuth required

      // authentication TrapMemberAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'TrapMemberAuth',
        ['read'],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * プロダクトキー作成
     * @summary プロダクトキー作成
     * @param {ProductKeyGen} productKeyGen
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postKeyGenerate: async (
      productKeyGen: ProductKeyGen,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'productKeyGen' is not null or undefined
      assertParamExists('postKeyGenerate', 'productKeyGen', productKeyGen);
      const localVarPath = `/launcher/key/generate`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication AdminAuth required

      // authentication TrapMemberAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'TrapMemberAuth',
        ['read'],
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        productKeyGen,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * ランチャーのログイン
     * @summary ランチャーのログイン
     * @param {ProductKey} productKey
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postLauncherLogin: async (
      productKey: ProductKey,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'productKey' is not null or undefined
      assertParamExists('postLauncherLogin', 'productKey', productKey);
      const localVarPath = `/launcher/login`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication LauncherAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication TrapMemberAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'TrapMemberAuth',
        ['read'],
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        productKey,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * LauncherAuthApi - functional programming interface
 * @export
 */
export const LauncherAuthApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    LauncherAuthApiAxiosParamCreator(configuration);
  return {
    /**
     * プロダクトキー失効
     * @summary プロダクトキー失効
     * @param {string} productKeyID productKeyのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteProductKey(
      productKeyID: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteProductKey(productKeyID, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * バージョンのプロダクトキー一覧
     * @summary バージョンのプロダクトキー一覧
     * @param {number} launcherVersionID ランチャーのバージョンのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getProductKeys(
      launcherVersionID: number,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ProductKeyDetail>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getProductKeys(
        launcherVersionID,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * プロダクトキー作成
     * @summary プロダクトキー作成
     * @param {ProductKeyGen} productKeyGen
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postKeyGenerate(
      productKeyGen: ProductKeyGen,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<ProductKey>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.postKeyGenerate(
        productKeyGen,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * ランチャーのログイン
     * @summary ランチャーのログイン
     * @param {ProductKey} productKey
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postLauncherLogin(
      productKey: ProductKey,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<LauncherAuthToken>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.postLauncherLogin(productKey, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * LauncherAuthApi - factory interface
 * @export
 */
export const LauncherAuthApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = LauncherAuthApiFp(configuration);
  return {
    /**
     * プロダクトキー失効
     * @summary プロダクトキー失効
     * @param {string} productKeyID productKeyのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteProductKey(productKeyID: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .deleteProductKey(productKeyID, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * バージョンのプロダクトキー一覧
     * @summary バージョンのプロダクトキー一覧
     * @param {number} launcherVersionID ランチャーのバージョンのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProductKeys(
      launcherVersionID: number,
      options?: any
    ): AxiosPromise<ProductKeyDetail> {
      return localVarFp
        .getProductKeys(launcherVersionID, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * プロダクトキー作成
     * @summary プロダクトキー作成
     * @param {ProductKeyGen} productKeyGen
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postKeyGenerate(
      productKeyGen: ProductKeyGen,
      options?: any
    ): AxiosPromise<Array<ProductKey>> {
      return localVarFp
        .postKeyGenerate(productKeyGen, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * ランチャーのログイン
     * @summary ランチャーのログイン
     * @param {ProductKey} productKey
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postLauncherLogin(
      productKey: ProductKey,
      options?: any
    ): AxiosPromise<LauncherAuthToken> {
      return localVarFp
        .postLauncherLogin(productKey, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * LauncherAuthApi - object-oriented interface
 * @export
 * @class LauncherAuthApi
 * @extends {BaseAPI}
 */
export class LauncherAuthApi extends BaseAPI {
  /**
   * プロダクトキー失効
   * @summary プロダクトキー失効
   * @param {string} productKeyID productKeyのID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LauncherAuthApi
   */
  public deleteProductKey(productKeyID: string, options?: any) {
    return LauncherAuthApiFp(this.configuration)
      .deleteProductKey(productKeyID, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * バージョンのプロダクトキー一覧
   * @summary バージョンのプロダクトキー一覧
   * @param {number} launcherVersionID ランチャーのバージョンのID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LauncherAuthApi
   */
  public getProductKeys(launcherVersionID: number, options?: any) {
    return LauncherAuthApiFp(this.configuration)
      .getProductKeys(launcherVersionID, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * プロダクトキー作成
   * @summary プロダクトキー作成
   * @param {ProductKeyGen} productKeyGen
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LauncherAuthApi
   */
  public postKeyGenerate(productKeyGen: ProductKeyGen, options?: any) {
    return LauncherAuthApiFp(this.configuration)
      .postKeyGenerate(productKeyGen, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * ランチャーのログイン
   * @summary ランチャーのログイン
   * @param {ProductKey} productKey
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LauncherAuthApi
   */
  public postLauncherLogin(
    productKey: ProductKey,
    options?: any
  ): Promise<boolean> {
    return LauncherAuthApiFp(this.configuration)
      .postLauncherLogin(productKey, options)
      .then((request) => request(this.axios, this.basePath))
      .then((res) => res.status === 200);
  }
}

/**
 * Oauth2Api - axios parameter creator
 * @export
 */
export const Oauth2ApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * OAuthのコールバック
     * @summary OAuthのコールバック
     * @param {string} code OAuth2.0のcode
     * @param {string} [sessions]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    callback: async (
      code: string,
      sessions?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'code' is not null or undefined
      assertParamExists('callback', 'code', code);
      const localVarPath = `/oauth2/callback`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication LauncherAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication TrapMemberAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'TrapMemberAuth',
        ['read'],
        configuration
      );

      if (code !== undefined) {
        localVarQueryParameter['code'] = code;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * OAuthのcode_challengeとかの取得
     * @summary OAuthのcode_challengeとかの取得
     * @param {string} [sessions]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGeneratedCode: async (
      sessions?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/oauth2/generate/code`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication LauncherAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication TrapMemberAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'TrapMemberAuth',
        ['read'],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * traP Collectionのログアウト
     * @summary traP Collectionのログアウト
     * @param {string} [sessions]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postLogout: async (
      sessions?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/oauth2/logout`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication TrapMemberAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'TrapMemberAuth',
        ['read'],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * Oauth2Api - functional programming interface
 * @export
 */
export const Oauth2ApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = Oauth2ApiAxiosParamCreator(configuration);
  return {
    /**
     * OAuthのコールバック
     * @summary OAuthのコールバック
     * @param {string} code OAuth2.0のcode
     * @param {string} [sessions]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async callback(
      code: string,
      sessions?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.callback(
        code,
        sessions,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * OAuthのcode_challengeとかの取得
     * @summary OAuthのcode_challengeとかの取得
     * @param {string} [sessions]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getGeneratedCode(
      sessions?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse200>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getGeneratedCode(sessions, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * traP Collectionのログアウト
     * @summary traP Collectionのログアウト
     * @param {string} [sessions]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postLogout(
      sessions?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.postLogout(
        sessions,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * Oauth2Api - factory interface
 * @export
 */
export const Oauth2ApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = Oauth2ApiFp(configuration);
  return {
    /**
     * OAuthのコールバック
     * @summary OAuthのコールバック
     * @param {string} code OAuth2.0のcode
     * @param {string} [sessions]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    callback(
      code: string,
      sessions?: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .callback(code, sessions, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * OAuthのcode_challengeとかの取得
     * @summary OAuthのcode_challengeとかの取得
     * @param {string} [sessions]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGeneratedCode(
      sessions?: string,
      options?: any
    ): AxiosPromise<InlineResponse200> {
      return localVarFp
        .getGeneratedCode(sessions, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * traP Collectionのログアウト
     * @summary traP Collectionのログアウト
     * @param {string} [sessions]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postLogout(sessions?: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .postLogout(sessions, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Oauth2Api - object-oriented interface
 * @export
 * @class Oauth2Api
 * @extends {BaseAPI}
 */
export class Oauth2Api extends BaseAPI {
  /**
   * OAuthのコールバック
   * @summary OAuthのコールバック
   * @param {string} code OAuth2.0のcode
   * @param {string} [sessions]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Oauth2Api
   */
  public callback(code: string, sessions?: string, options?: any) {
    return Oauth2ApiFp(this.configuration)
      .callback(code, sessions, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * OAuthのcode_challengeとかの取得
   * @summary OAuthのcode_challengeとかの取得
   * @param {string} [sessions]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Oauth2Api
   */
  public getGeneratedCode(sessions?: string, options?: any) {
    return Oauth2ApiFp(this.configuration)
      .getGeneratedCode(sessions, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * traP Collectionのログアウト
   * @summary traP Collectionのログアウト
   * @param {string} [sessions]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Oauth2Api
   */
  public postLogout(sessions?: string, options?: any) {
    return Oauth2ApiFp(this.configuration)
      .postLogout(sessions, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * SeatApi - axios parameter creator
 * @export
 */
export const SeatApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * 離席
     * @summary 離席
     * @param {Seat} seat
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSeat: async (seat: Seat, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'seat' is not null or undefined
      assertParamExists('deleteSeat', 'seat', seat);
      const localVarPath = `/seats`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication LauncherAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        seat,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 席の状態の取得
     * @summary 席の状態の取得
     * @param {number} seatVersionID 席のバージョンのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSeats: async (
      seatVersionID: number,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'seatVersionID' is not null or undefined
      assertParamExists('getSeats', 'seatVersionID', seatVersionID);
      const localVarPath = `/seats/versions/{seatVersionID}`.replace(
        `{${'seatVersionID'}}`,
        encodeURIComponent(String(seatVersionID))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication TrapMemberAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'TrapMemberAuth',
        ['read'],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 着席
     * @summary 着席
     * @param {Seat} seat
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postSeat: async (seat: Seat, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'seat' is not null or undefined
      assertParamExists('postSeat', 'seat', seat);
      const localVarPath = `/seats`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication LauncherAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        seat,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SeatApi - functional programming interface
 * @export
 */
export const SeatApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = SeatApiAxiosParamCreator(configuration);
  return {
    /**
     * 離席
     * @summary 離席
     * @param {Seat} seat
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteSeat(
      seat: Seat,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SeatDetail>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSeat(
        seat,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * 席の状態の取得
     * @summary 席の状態の取得
     * @param {number} seatVersionID 席のバージョンのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSeats(
      seatVersionID: number,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<SeatDetail>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getSeats(
        seatVersionID,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * 着席
     * @summary 着席
     * @param {Seat} seat
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postSeat(
      seat: Seat,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SeatDetail>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.postSeat(
        seat,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * SeatApi - factory interface
 * @export
 */
export const SeatApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = SeatApiFp(configuration);
  return {
    /**
     * 離席
     * @summary 離席
     * @param {Seat} seat
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSeat(seat: Seat, options?: any): AxiosPromise<SeatDetail> {
      return localVarFp
        .deleteSeat(seat, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 席の状態の取得
     * @summary 席の状態の取得
     * @param {number} seatVersionID 席のバージョンのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSeats(
      seatVersionID: number,
      options?: any
    ): AxiosPromise<Array<SeatDetail>> {
      return localVarFp
        .getSeats(seatVersionID, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 着席
     * @summary 着席
     * @param {Seat} seat
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postSeat(seat: Seat, options?: any): AxiosPromise<SeatDetail> {
      return localVarFp
        .postSeat(seat, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * SeatApi - object-oriented interface
 * @export
 * @class SeatApi
 * @extends {BaseAPI}
 */
export class SeatApi extends BaseAPI {
  /**
   * 離席
   * @summary 離席
   * @param {Seat} seat
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SeatApi
   */
  public deleteSeat(seat: Seat, options?: any) {
    return SeatApiFp(this.configuration)
      .deleteSeat(seat, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 席の状態の取得
   * @summary 席の状態の取得
   * @param {number} seatVersionID 席のバージョンのID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SeatApi
   */
  public getSeats(seatVersionID: number, options?: any) {
    return SeatApiFp(this.configuration)
      .getSeats(seatVersionID, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 着席
   * @summary 着席
   * @param {Seat} seat
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SeatApi
   */
  public postSeat(seat: Seat, options?: any) {
    return SeatApiFp(this.configuration)
      .postSeat(seat, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * SeatVersionApi - axios parameter creator
 * @export
 */
export const SeatVersionApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * 席のバージョン消去
     * @summary 席のバージョン消去
     * @param {number} seatVersionID 席のバージョンのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSeatVersion: async (
      seatVersionID: number,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'seatVersionID' is not null or undefined
      assertParamExists('deleteSeatVersion', 'seatVersionID', seatVersionID);
      const localVarPath = `/seats/versions/{seatVersionID}`.replace(
        `{${'seatVersionID'}}`,
        encodeURIComponent(String(seatVersionID))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication AdminAuth required

      // authentication TrapMemberAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'TrapMemberAuth',
        ['read'],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * バージョンに席のバージョン追加
     * @summary バージョンに席のバージョン追加
     * @param {number} launcherVersionID ランチャーのバージョンのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postSeatVersion: async (
      launcherVersionID: number,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'launcherVersionID' is not null or undefined
      assertParamExists(
        'postSeatVersion',
        'launcherVersionID',
        launcherVersionID
      );
      const localVarPath = `/versions/{launcherVersionID}/seats`.replace(
        `{${'launcherVersionID'}}`,
        encodeURIComponent(String(launcherVersionID))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication AdminAuth required

      // authentication TrapMemberAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'TrapMemberAuth',
        ['read'],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SeatVersionApi - functional programming interface
 * @export
 */
export const SeatVersionApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    SeatVersionApiAxiosParamCreator(configuration);
  return {
    /**
     * 席のバージョン消去
     * @summary 席のバージョン消去
     * @param {number} seatVersionID 席のバージョンのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteSeatVersion(
      seatVersionID: number,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteSeatVersion(
          seatVersionID,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * バージョンに席のバージョン追加
     * @summary バージョンに席のバージョン追加
     * @param {number} launcherVersionID ランチャーのバージョンのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postSeatVersion(
      launcherVersionID: number,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SeatVersion>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.postSeatVersion(
        launcherVersionID,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * SeatVersionApi - factory interface
 * @export
 */
export const SeatVersionApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = SeatVersionApiFp(configuration);
  return {
    /**
     * 席のバージョン消去
     * @summary 席のバージョン消去
     * @param {number} seatVersionID 席のバージョンのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSeatVersion(
      seatVersionID: number,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .deleteSeatVersion(seatVersionID, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * バージョンに席のバージョン追加
     * @summary バージョンに席のバージョン追加
     * @param {number} launcherVersionID ランチャーのバージョンのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postSeatVersion(
      launcherVersionID: number,
      options?: any
    ): AxiosPromise<SeatVersion> {
      return localVarFp
        .postSeatVersion(launcherVersionID, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * SeatVersionApi - object-oriented interface
 * @export
 * @class SeatVersionApi
 * @extends {BaseAPI}
 */
export class SeatVersionApi extends BaseAPI {
  /**
   * 席のバージョン消去
   * @summary 席のバージョン消去
   * @param {number} seatVersionID 席のバージョンのID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SeatVersionApi
   */
  public deleteSeatVersion(seatVersionID: number, options?: any) {
    return SeatVersionApiFp(this.configuration)
      .deleteSeatVersion(seatVersionID, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * バージョンに席のバージョン追加
   * @summary バージョンに席のバージョン追加
   * @param {number} launcherVersionID ランチャーのバージョンのID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SeatVersionApi
   */
  public postSeatVersion(launcherVersionID: number, options?: any) {
    return SeatVersionApiFp(this.configuration)
      .postSeatVersion(launcherVersionID, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * 自分の情報の取得
     * @summary 自分の情報の取得
     * @param {string} [sessions]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMe: async (
      sessions?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/users/me`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication TrapMemberAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'TrapMemberAuth',
        ['read'],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * traQの全ユーザー取得
     * @summary traQの全ユーザー取得
     * @param {string} [sessions]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsers: async (
      sessions?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/users`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication TrapMemberAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'TrapMemberAuth',
        ['read'],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration);
  return {
    /**
     * 自分の情報の取得
     * @summary 自分の情報の取得
     * @param {string} [sessions]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getMe(
      sessions?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getMe(
        sessions,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * traQの全ユーザー取得
     * @summary traQの全ユーザー取得
     * @param {string} [sessions]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUsers(
      sessions?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers(
        sessions,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = UserApiFp(configuration);
  return {
    /**
     * 自分の情報の取得
     * @summary 自分の情報の取得
     * @param {string} [sessions]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMe(sessions?: string, options?: any): AxiosPromise<User> {
      return localVarFp
        .getMe(sessions, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * traQの全ユーザー取得
     * @summary traQの全ユーザー取得
     * @param {string} [sessions]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsers(sessions?: string, options?: any): AxiosPromise<Array<User>> {
      return localVarFp
        .getUsers(sessions, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
  /**
   * 自分の情報の取得
   * @summary 自分の情報の取得
   * @param {string} [sessions]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public getMe(sessions?: string, options?: any) {
    return UserApiFp(this.configuration)
      .getMe(sessions, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * traQの全ユーザー取得
   * @summary traQの全ユーザー取得
   * @param {string} [sessions]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public getUsers(sessions?: string, options?: any) {
    return UserApiFp(this.configuration)
      .getUsers(sessions, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * VersionApi - axios parameter creator
 * @export
 */
export const VersionApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * ブラウザゲーム以外のゲームのID、MD5、ゲームの種類、更新日の一覧
     * @summary ブラウザゲーム以外のゲームのID、MD5、ゲームの種類、更新日の一覧
     * @param {string} operatingSystem osのパラメーター(mac,windows)
     * @param {string} [sessions]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCheckList: async (
      operatingSystem: string,
      sessions?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'operatingSystem' is not null or undefined
      assertParamExists('getCheckList', 'operatingSystem', operatingSystem);
      const localVarPath = `/versions/check`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication LauncherAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (operatingSystem !== undefined) {
        localVarQueryParameter['operatingSystem'] = operatingSystem;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * バージョンの詳細情報の取得
     * @summary バージョンの詳細情報の取得
     * @param {number} launcherVersionID ランチャーのバージョンのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVersion: async (
      launcherVersionID: number,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'launcherVersionID' is not null or undefined
      assertParamExists('getVersion', 'launcherVersionID', launcherVersionID);
      const localVarPath = `/versions/{launcherVersionID}`.replace(
        `{${'launcherVersionID'}}`,
        encodeURIComponent(String(launcherVersionID))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication LauncherAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication TrapMemberAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'TrapMemberAuth',
        ['read'],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * バージョン一覧の取得
     * @summary バージョン一覧の取得
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVersions: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/versions`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication TrapMemberAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'TrapMemberAuth',
        ['read'],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * バージョンへのゲームの追加
     * @summary バージョンへのゲームの追加
     * @param {number} launcherVersionID ランチャーのバージョンのID
     * @param {Array<string>} requestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postGameToVersion: async (
      launcherVersionID: number,
      requestBody: Array<string>,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'launcherVersionID' is not null or undefined
      assertParamExists(
        'postGameToVersion',
        'launcherVersionID',
        launcherVersionID
      );
      // verify required parameter 'requestBody' is not null or undefined
      assertParamExists('postGameToVersion', 'requestBody', requestBody);
      const localVarPath = `/versions/{launcherVersionID}/game`.replace(
        `{${'launcherVersionID'}}`,
        encodeURIComponent(String(launcherVersionID))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication AdminAuth required

      // authentication TrapMemberAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'TrapMemberAuth',
        ['read'],
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestBody,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 新しいバージョンの作成
     * @summary 新しいバージョンの作成
     * @param {NewVersion} newVersion
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postVersion: async (
      newVersion: NewVersion,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'newVersion' is not null or undefined
      assertParamExists('postVersion', 'newVersion', newVersion);
      const localVarPath = `/versions`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication AdminAuth required

      // authentication TrapMemberAuth required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        'TrapMemberAuth',
        ['read'],
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        newVersion,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * VersionApi - functional programming interface
 * @export
 */
export const VersionApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = VersionApiAxiosParamCreator(configuration);
  return {
    /**
     * ブラウザゲーム以外のゲームのID、MD5、ゲームの種類、更新日の一覧
     * @summary ブラウザゲーム以外のゲームのID、MD5、ゲームの種類、更新日の一覧
     * @param {string} operatingSystem osのパラメーター(mac,windows)
     * @param {string} [sessions]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCheckList(
      operatingSystem: string,
      sessions?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<CheckItem>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getCheckList(
        operatingSystem,
        sessions,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * バージョンの詳細情報の取得
     * @summary バージョンの詳細情報の取得
     * @param {number} launcherVersionID ランチャーのバージョンのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getVersion(
      launcherVersionID: number,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<VersionDetails>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getVersion(
        launcherVersionID,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * バージョン一覧の取得
     * @summary バージョン一覧の取得
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getVersions(
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Version>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getVersions(
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * バージョンへのゲームの追加
     * @summary バージョンへのゲームの追加
     * @param {number} launcherVersionID ランチャーのバージョンのID
     * @param {Array<string>} requestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postGameToVersion(
      launcherVersionID: number,
      requestBody: Array<string>,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<VersionDetails>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.postGameToVersion(
          launcherVersionID,
          requestBody,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * 新しいバージョンの作成
     * @summary 新しいバージョンの作成
     * @param {NewVersion} newVersion
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postVersion(
      newVersion: NewVersion,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<VersionMeta>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.postVersion(
        newVersion,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * VersionApi - factory interface
 * @export
 */
export const VersionApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = VersionApiFp(configuration);
  return {
    /**
     * ブラウザゲーム以外のゲームのID、MD5、ゲームの種類、更新日の一覧
     * @summary ブラウザゲーム以外のゲームのID、MD5、ゲームの種類、更新日の一覧
     * @param {string} operatingSystem osのパラメーター(mac,windows)
     * @param {string} [sessions]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCheckList(
      operatingSystem: string,
      sessions?: string,
      options?: any
    ): AxiosPromise<Array<CheckItem>> {
      return localVarFp
        .getCheckList(operatingSystem, sessions, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * バージョンの詳細情報の取得
     * @summary バージョンの詳細情報の取得
     * @param {number} launcherVersionID ランチャーのバージョンのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVersion(
      launcherVersionID: number,
      options?: any
    ): AxiosPromise<VersionDetails> {
      return localVarFp
        .getVersion(launcherVersionID, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * バージョン一覧の取得
     * @summary バージョン一覧の取得
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVersions(options?: any): AxiosPromise<Array<Version>> {
      return localVarFp
        .getVersions(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * バージョンへのゲームの追加
     * @summary バージョンへのゲームの追加
     * @param {number} launcherVersionID ランチャーのバージョンのID
     * @param {Array<string>} requestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postGameToVersion(
      launcherVersionID: number,
      requestBody: Array<string>,
      options?: any
    ): AxiosPromise<VersionDetails> {
      return localVarFp
        .postGameToVersion(launcherVersionID, requestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * 新しいバージョンの作成
     * @summary 新しいバージョンの作成
     * @param {NewVersion} newVersion
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postVersion(
      newVersion: NewVersion,
      options?: any
    ): AxiosPromise<VersionMeta> {
      return localVarFp
        .postVersion(newVersion, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * VersionApi - object-oriented interface
 * @export
 * @class VersionApi
 * @extends {BaseAPI}
 */
export class VersionApi extends BaseAPI {
  /**
   * ブラウザゲーム以外のゲームのID、MD5、ゲームの種類、更新日の一覧
   * @summary ブラウザゲーム以外のゲームのID、MD5、ゲームの種類、更新日の一覧
   * @param {string} operatingSystem osのパラメーター(mac,windows)
   * @param {string} [sessions]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VersionApi
   */
  public getCheckList(
    operatingSystem: string,
    sessions?: string,
    options?: any
  ) {
    return VersionApiFp(this.configuration)
      .getCheckList(operatingSystem, sessions, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * バージョンの詳細情報の取得
   * @summary バージョンの詳細情報の取得
   * @param {number} launcherVersionID ランチャーのバージョンのID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VersionApi
   */
  public getVersion(launcherVersionID: number, options?: any) {
    return VersionApiFp(this.configuration)
      .getVersion(launcherVersionID, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * バージョン一覧の取得
   * @summary バージョン一覧の取得
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VersionApi
   */
  public getVersions(options?: any) {
    return VersionApiFp(this.configuration)
      .getVersions(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * バージョンへのゲームの追加
   * @summary バージョンへのゲームの追加
   * @param {number} launcherVersionID ランチャーのバージョンのID
   * @param {Array<string>} requestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VersionApi
   */
  public postGameToVersion(
    launcherVersionID: number,
    requestBody: Array<string>,
    options?: any
  ) {
    return VersionApiFp(this.configuration)
      .postGameToVersion(launcherVersionID, requestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * 新しいバージョンの作成
   * @summary 新しいバージョンの作成
   * @param {NewVersion} newVersion
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VersionApi
   */
  public postVersion(newVersion: NewVersion, options?: any) {
    return VersionApiFp(this.configuration)
      .postVersion(newVersion, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
